timestamp,author,subject,email,email_url,tokens
2023-02-27 13:32:01+00:00,Rastislav Budinsky,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"Hello, I am working on my Bachelor's thesis, in which a new way of collecting transaction fees is introduced or rather how they are distributed. When a miner mines a block he takes all the fees currently. However with the proposed solution he takes only fraction M and remaining fraction C is sent to one of more contracts. One contract at its simplest collects fees from the miner and at the same time redistributes it back to the miner. This means no new Bitcoins are introduced, only the one collected from fees are collected, averaged and rewarded back to the miner in a ""smarter"" way. We can have multiple such contracts, where each averages the collected fees over different time frames. I would like to refer you to our paper for more details [1], which is not yet in the final form. Benefits are discussed in the paper [1] as well, mainly it should make mining more secure and predictable against drastic fluctuations in fees. I personally do not think miners should oppose this solution as for most miners it should make a better mining environment. Similarly in a sense to what mining pools bring. I would like to know your opinions about this proposal and we can also discuss the needed parameters introduced with such a solution if you are in favor of it or think it might be interesting. Introducing this solution soon enough will not make a great difference to miners with current block rewards and at the same time the contracts will be adapted before transaction fees become the main source of income for miners. As I have very little to none developer experience from blockchain's point (especially on Bitcoin), I am not sure if this would be possible as soft-fork as scripts in Bitcoin are stateless I suppose. However maybe a generally spendable script by anyone holding the funds is created, which a miner of the block would be the one spending it, and the correct logic of following the contracts is embedded into consensus nodes themselves. Thus perhaps a less disruptive solution to hard-fork. Once again, I would love to know your opinions about this & I apologize for making this a bit less conventional BIP proposal. Best regards.",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021505.html,421
2023-02-27 21:41:35+00:00,HcaFc_jbe,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"Greetings, Brno is a beautiful city. Long term miner incentives remain an open question, and this is an interesting proposal, but it has flaws. -----To intervene or not intervene --No intervention: When block subsidies do run out, years from now, it's possible that we live in a world where ordinals, LN-settlements, and on-chain transactions will be filling block space to the extent that miners are incentivized to continue mining. --Intervention: Tail-emissions? Demurrage? Fee-redistribution schemes like this one? Really, it is too early to say whether mining incentives _will even_ be a problem, let alone _what_ the solution(s) should be. This fee-redistribution scheme aims to solve 1. Undercutting attacks [which have been precluded AFAIK with anti fee-sniping nLocktime since Core 0.11] 2. Fee-variance between blocks, whether due to the mining gap or variance in block demand. --Flaws 0. A miner in this world could be more aggressive in excluding certain blocks to the detriment of their counter parties. I.e. If a miner can ignore high-fee transactions, knowing they won't receive the _benefits_ of mining them [or less benefit], they can exclude these transactions without losing fees. E.g. if a miner is or represents a counterparty in a LN commitment transaction, and this counter party prefers that a time threshold is reached [so that they can mine a different version of the commitment transaction] then under this scheme they can avoid mining the first commitment transaction without really losing its fee, since it's fee is socialized anyway. This attack then becomes free or very cheap. 1. How would this smart-contract actually be constructed? The paper contains no references to op_codes or implementations. You do mention that you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_ with the current Script, and could remain impossible. Maybe DLCs could be applied somehow. IDK. 2.0. I think it will be difficult to convince the ecosystem that the mining incentive structure should be changed from competitive to cooperative. This effectively changes the mining ecosystem into one giant mining pool. How would this affect mining centralization? 2.1. How do we achieve miner consensus in implementing the fee-redistribution scheme? And what is the consensus for updating? ---Paper-nits: I believe the distribution in block creation is not exponential, but poisson -> on page two it's described as exponential. Cheers, -Paul ------- Original Message -------",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021506.html,530
2023-02-28 10:02:47+00:00,shymaa arafat,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"If you allow me to comment (just with a bird eye, have not read the paper only the abstract) I think the Bitcoin community may consider the intuition of somewhat ""Future Saving"" through TX fees: ie, the idea of saving a ratio of the fees (say half to be decreased to half with each reward halving)is worth thinking of: Keep in mind that the block reward problem will not start only in 2140, but when the mining cost becomes comparable to the reward value (could this be as near as 2040?I don't know, you know the answer better than me) . -So, why not start a fee splitting mechanism in analogy to reward splitting mechanism *(the saved ratio is half the total now, and to be halved with every Bitcoin reward halving until a threshold is reached where the saved amounts gets added to the low block reward)* Ofcourse this is very rough, a game theoritic model has to be built with the appropriate incentives and costs to get the exact numbers . Thank you for letting me comment in your list . Regards . Shymaa M Arafat",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021507.html,225
2023-02-28 18:07:06+00:00,Dhruv M,[bitcoin-dev] Refreshed BIP324,"The relevant changes from this discussion about short 1-byte message type IDs are now in a PR for the bips repo: https://github.com/bitcoin/bips/pull/1428 On 2/21/23 08:03, Anthony Towns via bitcoin dev wrote:",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021508.html,58
2023-02-28 21:02:41+00:00,Erik Aronesty,[bitcoin-dev] Refreshed BIP324,"you can always do what protocols usually do. 1 byte is fine for now, but reserve the top bit for ""this is a two byte id"" (128 choices). then when you run out of room, set the top bit which means ""this is a 2 byte id (again with one reserved) and so-on. ie: how protobuf stores integers.",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021509.html,74
2023-03-01 15:05:47+00:00,Greg Sanders,[bitcoin-dev] BIP for OP_VAULT,"Hello James, First off, thank you for crafting an interesting idea like this that is aimed at solving a serious problem. I see a lot of excitement about the use cases, and I think it's worth iterating on. Attempting to keep the idealized functionality constant, I'd like to explore a design detour. I'm attempting to decouple the 3 functionalities of `OP_VAULT` and `OP_UNVAULT` into their constituent functions with names I just made up. The goals of this e-mail: 1) Removing variable number of arguments based on values of arguments for the opcodes. To me as a spec reader, I find it very difficult to parse what's precisely happening when. I think the only/last opcode to support this behavior was OP_CHECKMULTISIG(could be wrong), and now I know another reason why OP_CSA construct is nicer going forward with taproot. 2) Remove the recursive evaluation functionality used for authentication, without reducing the efficacy of the targeted solution. Recursive evaluation has a fraught history in Bitcoin script, makes composing functionality with tooling likely more difficult, and has a lot of templated behavior. If we can rely on regular old tapscript to get us where we need to go, I'd prefer that. 3) Increase legibility of the spec. There's a ton going on, breaking things up and naming them based on the method rather than the goal may help here. 4) Not (greatly) increase the expressiveness of the proposal. It's a targeted proposal, and I'd like to respect that. These covenant opcodes are intended to be drop-in replacements for the OP_(UN)VAULT opcodes. To recap, there are three things happen in idealized OP_VAULT scenario: 1) Money comes out, then has to wait (trigger transaction) 2) Money waits long enough, then withdrawals to dynamic set of outputs that are declared at trigger time (withdrawal transaction) 3) Money to single specified output script picked up front, with no wait (recovery) Below is a sketch of a replacement for the two opcodes. Ignore my inconsistency on VERIFY/non-VERIFY behavior, seeing if people agree with this general direction: `OP_TRIGGER_FORWARD`: Takes exactly three arguments: 1) output index to match against (provided at spend time normally) 2) target-outputs-hash: 32 byte hash to be forwarded to output given at (1) (provided at spend time normally) 3) spend-delay: value to be forwarded to output given at (1) Fails script immediately if there aren't enough inputs or they're the wrong format. These last two arguments are ""forwarded"" to output at index declared in first argument, resulting in: `EXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP <target-outputs-hash> OP_FORWARD_OUTPUTS` As the derived tapscript, embedded in a output scriptpubkey of the form: `tr(NUMS,{..,EXPR_WITHDRAW})`, meaning we literally take the control block from the spending input, swap the inner pubkey for `NUMS`, use `EXPR_WITHDRAW` as the tapleaf, reconstruct the merkle root. If the output scriptpubkey doesnt match, fail. This TLUV-ish script/inner pubkey replacement is meant to allow arbitrary other conditions, which is where the ""recovery"" path comes in for typical usage. If output at the target output index doesn't match the constructed script, the evaluation fails. `OP_FORWARD_DESTINATION`: Takes exactly two arguments: 1) `dest-vout-idx`: index of output that contains the so-called ""recovery"" path 2) <recovery sPK tagged hash (32 bytes)>: the hash of the script destination Fails immediately if the reconstructed output script doesn't match. `OP_FORWARD_OUTPUTS` takes exactly one argument: 1) target-outputs-hash: commits to all outputs' scripts and values Fails immediately if transaction's outputs(including value) hash doesn't match. **Typical usage**: ``` DEPOSITING TO VAULT SCRIPT: EXPR_RECOVERY: <recovery> <auth> <stuff> <recovery sPK tagged hash (32 bytes)> OP_FORWARD_DESTINATION EXPR_TRIGGER: <trigger> <auth> <stuff> <spend-delay> OP_TRIGGER_FORWARD tr(KEY, {EXPR_RECOVERY, EXPR_TRIGGER}) ``` ``` EXPR_WITHDRAW: <spend-delay> OP_CHECKSEQUENCEVERIFY OP_DROP <target-outputs-hash> OP_FORWARD_OUTPUTS ``` ``` TRIGGERING WITHDRAWAL TIMER SCRIPT: tr(NUMS, {EXPR_RECOVERY,EXPR_WITHDRAW}) <--- note EXPR_RECOVERY is forced by the OP_TRIGGER_FORWARD TLUV action ``` Could save 2 WU having OP_FORWARD_OUTPUTS take the <spend-delay> directly as an argument, or keep it more general as I did. Would love to know what you and others think about this direction. I apologies for any misunderstandings I have about the current OP_VAULT BIP! Cheers, Greg",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021510.html,1044
2023-03-01 17:17:58+00:00,David A. Harding,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"On 2023 02 27 03:32, Rastislav Budinsky via bitcoin dev wrote: Hi Rastislav, I think you've incorrectly made the assumption that the only way a miner can profit from confirming a transaction is by collecting its transaction fees. Miners can (and many have) accept payment through alternative means, which the Bitcoin technical community often calls ""out-of-band fees"".[1] For example, some miners have provided a ""transaction accelerator"" service that accepts fiat-denominated credit cards to increase their prioritization of certain transactions and I'm personally aware of a large web wallet provider that would occasionally pay miners out of band to confirm hundreds or thousands of transactions rather than fix its broken fee estimation. Out-of-band fees aren't frequently used in Bitcoin today because they have no advantage over correctly estimated in-band fees, and good fee estimation is very accessible to modern wallets. However, if the consensus rules are changed to require each miner pay a percentage of its in-band fees to future miners, then there would be a strong incentive for them to prefer out-of-band fees that weren't subject to this redistribution scheme. I think may have seen a variation on the scheme you propose play out in real life. Here's how it works where I live: the government imposes taxes on goods, services, and income. Ostensibly, it redistributes the collected funds back to citizens in the future by providing government services. When I go to pay someone who trusts my discretion, they often offer me a discounted rate if I pay in a way that isn't reported to the government (e.g., I pay with cash); even with the discount provided to me, they get to keep more of their income than if they had reported the transaction to the government. In the case of a government, tax evasion can be reduced by the deployment of investigators and enforcers. In Bitcoin, we have no control over activity that happens outside of the protocol and so even a modest incentive to pay fees out of band might quickly lead to almost all fees being paid out of band. This prevents the effective redistribution of fees as in your proposal. Additionally, previous discussions on this mailing list about paying out-of-band fees have highlighted that larger miners have an advantage over smaller miners in collecting miner-specific fee payments, undermining the essential decentralization of Bitcoin's transaction confirmation mechanism (moreso than it is already weakened by fundamental economies of scale in mining). In short, I think serious consideration of your proposal can only proceed if it adequately addresses the problem of out-of-band fees. That said, thank you and your co-authors for putting serious thought into Bitcoin's long-term economic incentives. -Dave",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021511.html,540
2023-03-01 20:18:22+00:00,Giuseppe B,[bitcoin-dev] Minimum fees,"Hello everyone, I'm relatively new here so what I'm proposing could have already been discussed, or may be flawed or inapplicable. I apologize for that. I was picturing a situation where block rewards are almost zero, and the base layer is mainly used as a settlement layer for relatively few large transactions, since the majority of smaller ones goes through LN. In such a case it may very well be that even if transaction amounts are very consistent, transaction fees end up being very small since there is enough space for everyone in a block. Users wouldn't mind paying higher fees as they know that that would increase the network security, however nobody wants to be the only one doing that. Miners would of course like being paid more. So everyone involved would prefer higher fees but they just stay low because that's the only rational individual choice. Therefore I was imagining the introduction of a new protocol rule, min_fees, that would work like this: - the miner that gets to mine a block appends a min_fee field to the block, specifying the minimum fees that need to be contained in the following block in order for it to be valid. - one can also mine an empty block and reset the min_fee, to avoid the chain getting stuck. min_fees could either represent the total fees of the following block, or the minimal fee for each single transaction, as a percentage of the value transacted. Both seem to have some merits and some potential drawbacks. Of course min_fees=0 would correspond to the current situation. It looks to me that this could have the potential to bring the equilibrium closer to a socially optimal one (as opposed to individually optimal), and to benefit the network security in the long term. Of course it's just a rough sketch and it would deserve a much deeper analysis. I was just interested in knowing if you think that the principle has some merit or if it's not even worth discussing it for some reason that I'm not considering. Cheers, Giuseppe.",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021512.html,402
2023-03-02 00:39:13+00:00,Nadav Ivgi,[bitcoin-dev] Minimum fees,"Hi Giuseppe, One side effect this has is that until enough fees accumulate in the mempool to satisfy min_fees, the rational behaviour for miners would be to try and fork the chain tip, competing for the fees in the latest block (+whatever got into the mempool in the meanwhile and can fit in). This could lead to increased reorgs/orphan rates and chain instability. It could also lead to miners preferring to set their low_fee to zero, to avoid other miners from forking their blocks off. I'm also not sure that this would actually change much. If humanity is willing to spend X BTC/day on mining fees, it doesn't really matter if it's spread out through fewer or more blocks. shesek",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021513.html,148
2023-03-02 04:46:25+00:00,Anthony Towns,[bitcoin-dev] BIP for OP_VAULT,"I like this! I tried to come up with something along similar lines for similar reasons, but I think I tried too hard to reduce it to two opcodes or something and got myself confused. I think you could generalise this as follows: idx . npush script OP_FORWARD_LEAF_UPDATE (OP_FLU :) with the behaviour being: pop script from the stack pop npush from the stack (error if non-minimal or <0) pop npush entries from the stack, prefix script with a minimal push of that entry pop idx off the stack (error if idx is not a valid output) calculate the spk corresponding to taking the current input's spk and replacing the current leaf with the given script check the output at idx matches this spk, and the value from this input accumulates to that output Then instead of `idx hash delay OP_TRIGGER_FORWARD` you write `idx hash delay 2 ""OP_CSV OP_DROP OP_FORWARD_OUTPUTS"" OP_FORWARD_LEAF_UPDATE` That's an additional 5 witness bytes, but a much more generic/composable opcode. Being able to prefix a script with push opcodes avoids the possibility of being able to add OP_SUCCESS instructions, so I think this is a fairly safe way of allowing a TLUV-ish script to be modified, especially compared to OP_CAT. I do recognise that it makes it take a variable number of stack elements though :) I don't think replacing the internal-public-key makes sense -- if it was immediately spendable via the keypath before there's no reason for it not to be immediately spendable now. Having OP_FORWARD_OUTPUTS not leave its input on the stack would let you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU. I think the existing OP_VAULT cleverness would work here, allowing you to spend two inputs to the same output, accumulating their values. I don't think it quite gives you a way to ""refund"" values though -- so that you can take a vault with 3 BTC, start the <delay> wait to spend 1.4 BTC, and then immediately decide to spend an additional 0.8 BTC on something else, without the 0.8 BTC effectively having a doubled delay. I think you could fix that with something as simple as an additional ""idx OP_FORWARD_REFUND"" opcode, though -- then the restriction is just that the output at the refund idx has the same sPK as this input, and the total value of this input is accumulated amongst all the outputs specified by OP_FORWARD opcodes. (Maybe you need to specify the refund amount explicitly as well, to keep verification easy) That would make maybe three new opcodes to cover the ""accumulate value from one or more inputs into specified outputs"": - OP_FORWARD_LEAF_UPDATE --> forward input value to modified spk - OP_FORWARD_DESTINATION --> forward input value to given spk - OP_FORWARD_REFUND --> forward part of input value to same spk along with OP_CTV: - OP_FORWARD_OUTPUTS --> pay to specific outputs OP_VAULT's ""accumulate value"" behaviour here makes the OP_IN_OUT_AMOUNT things from TLUV more implicit and automatic, which is nice. I think doing TLUV payment pools wouldn't require much more than the ability to combine OP_FLU and OP_FDEST in a single script, explicitly specifying how much value is extracted via OP_FDEST with the rest assigned to OP_FLU. Cheers, aj",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021514.html,702
2023-03-02 06:55:19+00:00,kcalvinalvin,[bitcoin-dev] Using service bit 24 for utreexo signaling in testnet and signet,"Hello all, Wanted to tell the mailing list that I'll be using service bit 24 (1 << 24) to signal that nodes are Utreexo capable nodes on testnet and signet as requested by the comment in protocol.h in bitcoind (https://github.com/bitcoin/bitcoin/blob/74981aa02d2b14ad1c0b82d1eb09cf3169eaa8ae/src/protocol.hL295-L301). There are plans to release binaries for the utreexo node (github.com/utreexo/utreexod) in the next few months so that power users can try it out. I have no plans to release binaries for mainnet yet. Do let me know if someone else is using the same bit to signal for something else and we can coordinate accordingly. Best, Calvin",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021515.html,174
2023-03-02 14:54:31+00:00,Greg Sanders,[bitcoin-dev] BIP for OP_VAULT,"Greetings AJ, Glad I could resurrect the idea! write `idx hash delay 2 ""OP_CSV OP_DROP OP_FORWARD_OUTPUTS"" OP_FORWARD_LEAF_UPDATE` Interesting idea! (I'll let you be the one to scope creep the proposal :) ) To be pedantic, EXPR_TRIGGER would become: <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE and at spend time the idx and hash are put into the witness stack. To be clear, <spend-delay> could be embedded in the <script> too, right, making <2> a <1> in the above? Any reason for one or the other? Another bonus from this is that you can introduce withdrawal authorization as well as part of the <script>. Current proposal has no withdrawal authorization, from what I understand. So each transition in a vault construct can have authorization, if it desires it. though :) Just when I thought I was out, they pulled me back in. was immediately spendable via the keypath before there's no reason for it not to be immediately spendable now. Slavishly following the current proposal was the idea to make sure all functionality was captured; I agree with this change. you move the OP_CSV to the end and drop the OP_DROP too, saving 1 WU. Previously setting CSV timeout to 0 would result in it not being satisfiable, if I'm understanding the suggestion correctly. I suppose this was a side-effect of having OP_UNVAULT take this value directly. Indeed with `OP_FORWARD_OUTPUTS` being split out there's not really a reason to use a 0 value? to spend two inputs to the same output, accumulating their values. Yes I think batching story should be same hopefully. I am assuming all the accounting OP_VAULT is doing is being done here. We match against the hash passed in, and fits into the ""deferred checks"" IIUC. Again, to be pedantic EXPR_TRIGGER becomes: <trigger> <auth> <stuff> <spend-delay> <2> <OP_CSV OP_DROP OP_FORWARD_OUTPUTS> OP_FORWARD_LEAF_UPDATE OP_FORWARD_REFUND Resulting in 2 more WU at spend time(for small idx). So *up front* committing to a refund path, perhaps with value explicitly passed in. Totally forgot about the refund path; will need to mull the issue over, see how it interacts with BYOF schemes, etc. Cheers, Greg",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021516.html,518
2023-03-02 18:20:35+00:00,Luke Dashjr,[bitcoin-dev] Using service bit 24 for utreexo signaling in testnet and signet,"This sounds like something that should be written up as a BIP and use a normal service bit assignment..? Luke On 3/2/23 01:55, kcalvinalvin via bitcoin dev wrote:",https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-March/021517.html,44
