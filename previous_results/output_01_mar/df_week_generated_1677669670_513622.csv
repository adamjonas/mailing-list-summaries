date,subject,num_replies,authors,urls,generated_summaries,consolidated_title,consolidated_summary
2023-02-27 13:32:01,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,3,"['Rastislav Budinsky', 'HcaFc_jbe', 'shymaa arafat']","['https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021505.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021506.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021507.html']","[""This proposal introduces a new way of collecting and distributing transaction fees when a miner mines a block. The miner would take only a fraction (M) of the fee, while the remaining fraction (C) is sent to one or more contracts which collect fees from the miner and redistribute it back to them. This does not introduce any new Bitcoins, only those collected from fees are collected, averaged and rewarded back to the miner in a 'smarter' way. Multiple contracts can be used, each averaging the collected fees over different time frames. Benefits discussed in the paper include making mining more secure and predictable against drastic fluctuations in fees. It offers miners a better environment than what they have currently with block rewards and the contracts will be adapted before transaction fees become the main source of income for miners. It is proposed that this solution could be implemented as a soft-fork, with scripts in Bitcoin being stateless, and a generally spendable script by anyone holding the funds created, which a miner of the block would be the one spending it. The correct logic of following the contracts would then need to be embedded into consensus nodes themselves."", 'Brno is a beautiful city, and this proposal aims to solve the potential issue of long-term miner incentives. It suggests either intervening or not intervening when block subsidies run out. Not intervening would mean relying on ordinals, LN-settlements and on-chain transactions to fill block space, while intervention could involve tail-emissions, demurrage or fee-redistribution schemes such as this one. However, there are flaws with this proposal. A miner in this case could be more aggressive in excluding certain blocks which could be to the detriment of their counter parties. Additionally, there is no reference to op-codes or implementations in the paper, and it could remain impossible to achieve miner consensus for implementing the fee-redistribution scheme with the current Script. Lastly, changing the mining incentive structure from competitive to cooperative may affect mining centralization.', 'Shymaa M Arafat suggests that the Bitcoin community consider a ""Future Saving"" through TX fees as a potential solution to the block reward problem. This would involve a mechanism to save a portion of the fees and decrease it by half with each reward halving until a threshold is reached when the saved amounts get added to the low block reward. However, this idea needs further research and a game theoretic model must be built to calculate exact numbers for the incentives and costs. The block reward problem may not start in 2140 but rather when mining cost becomes comparable to reward value, which could be as early as 2040.']","""Exploring a Smarter Way of Redistributing Transaction Fees: Towards Future Saving in Bitcoin Mining""","Shymaa M Arafat proposes a solution to the block reward problem which could arise when mining cost becomes comparable to reward value, likely as early as 2040. This solution involves a mechanism to save a portion of transaction fees and redistribute it back to the miner in a 'smarter' way; i.e. multiple contracts can be used, each averaging the collected fees over different time frames, making mining more secure and predictable against drastic fluctuations in fees. It is proposed that this solution could be implemented as a soft-fork, with scripts in Bitcoin being stateless, and generally spendable script by anyone holding the funds created. However, there are flaws with this proposal, such as miners being more aggressive in excluding certain blocks, there being no reference to op-codes or implementations, and changing the mining incentive structure from competitive to cooperative may affect mining centralization."
2023-02-22 16:29:03,[bitcoin-dev] Codex32,6,"['Peter Todd', ""Russell O'Connor"", ""Russell O'Connor"", ""Russell O'Connor"", ""Russell O'Connor"", ""Russell O'Connor""]","['https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021498.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021500.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021501.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021502.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021503.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021504.html']","[""The use-case mentioned is not suitable as the checksum used by Codex32 is too complex. A simpler approach would be to use a mod N = 0 checksum either by creating the seed such that each share passes, or by storing an additional word/symbol with the seed in such a way that sum(words) mod N = 0 passes. This approach can be computed by hand with a word/symbol->number lookup table, and pen and paper or a calculator. Furthermore, if all shares have mod N checksums, it may be sufficient for everyone to write down the checksums of the other shares, to verify they are the correct ones and a different (otherwise correct) share hasn't been substituted. It is possible to generate Shamir's secret sharing shards such that every shard can share the same checksum. In this case, the verification procedure would be to ask every share holder to verify the checksum manually using the mod N procedure, and then verify that each share holder has the same checksum. This method, although not fool proof, is better than a complex procedure that people don't actually do at all."", 'Error correction in Codex32 can be aided by a computer with minimal trust. If the final residue calculated through hand computation does not match with the value given in the codex32 spec, it suggests an error in the share data. An error correction string can be generated by plugging the incorrect residue into a computer and adding this error correction string to the share to get a corrected share. All types of character errors are not equally likely, and hence the computer can learn a little bit about the share. A single share from a split secret does not have any information about the master seed as it is hidden in correlation between different shares. Moreover, there is no native support for nested SSSS in codex32, but a design for second level share scheme exists. While hardware wallets provide practical protection, they need to interact with the Bitcoin protocol and P2P network to function, which results in compromising the secret data. To mitigate such issues, vectors such as anti-exfil signing, air gapping the hardware wallet and using multiple wallets from different vendors doing deterministic signing can be used.', ""The 13 character generator for regular sized shares has roots at T{11}, S{16}, and C{24}. It is possible to create a “quick check” worksheet to evaluate the string modulo (x - T) to verify a 5 bit checksum. One could also work modulo (x - T) * (x - S) to get a 10 bit checksum, or create a worksheet for a 15 bit checksum. The smoothness of the long generator for seeds greater than 400 bits has not been investigated yet, but if it isn't smooth and smoother options are available, then it should be changed."", 'After taking advice into consideration, it has been concluded that generators for degree 2 BCH codes, such as ours, are smooth and can be divided into quadratic and linear components. This allows us to perform a ""quickcheck"" verification of the codex32 strings in any size - from 1 character to 13 characters. For instance, a 1 character quickchecksum will guarantee detection of any single error, while a 3 character quickchecksum will detect up to two character errors. It is worth noting that there is still a 1 in 32^n chance of not recognizing higher numbers of errors, where n is the size of the quickcheck. To illustrate this, let\'s consider a quickcheck of size 2. It will detect any 1 character error and will have only a 1/1024 chance of failing to identify other random errors. As an example, consider the second test vector: ""MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"". To do this, the process starts with a specific initial state containing two Bech32 characters for MS1 strings and a size 2 quickcheck, which will be \'AS\'. Then, the first character after the prefix is ""added"", which is \'2\' in this case. This adds to \'S\' to give \'6\', thus making \'A6\' the current state. \'A6\' is looked up in a lookup table (too large to mention here) and it is mapped to \'QM\'. The state is then changed to \'QM\' and the next two characters in the string – \'NA\' – are added using the volvelle or lookup table. This gives \'N\' and \'X\', making \'NX\' the new state. Looking up \'NX\' in the same lookup table yields an entry mapping to \'DX\', which becomes our new state. This procedure is repeated until the end is reached, giving a final state of \'H9\'. This process can be used with any string up to 400 bit master seeds and will always yield the state \'H9\'. A specialized worksheet would help simplify the process. Peter Todd\'s suggestion of using a lookup table on ""words"" (pairs of Bech32 characters) and adding values together was taken into account, though the addition requires Bech32 rather than calculator addition. Thus, partial verification can be done manually to whatever extent desired, although a larger risk of failing to identify random errors is present.', 'The 1 character ""quick check"" is too small to be reliably used, as it has a 1 in 32 chance of failing to detect errors. Making the adjustment to the codex32 generator so that this 1 character quick check table would become identical to the Bech32 addition table would come at a cost, losing the special property of having three identical coefficients in a row which slightly eases the computation needed when creating checksums by hand. Therefore, it is not worth compromising the ease of hand computation for the sake of making a low-quality checksum more convenient, as it is recommended that people perform quick checks with a minimum size of 2 which has a 0.1% failure rate.', 'Performing 2 character quick checks is an effective way to verify the accuracy of a string. There are 7 different ways of building the table used in this process, and employing each one of them is equivalent to performing a full checksum verification. Adopting this strategy involves visiting the shares on a regular basis and changing the 2 character quick check order each time. By following this prescribed order, it is possible to accumulate BCH guarantees such as detecting 1 character error after the 1st table, 2 character error after the 2nd table, 4 character error after the 3rd table, 5 character error after the 4th table, 6 character error after the 5th table, 7 character error after the 6th table, and 8 character error (equivalent to the guarantee of the full 13 character checksum) after the 7th table. Although more work than doing the full 13 character checksum validation, it has advantages such as catching any new 1 character error introduced since the last visit, and 99.9% chance of catching any other random errors introduced since the last visit.']","""Verifying Accuracy of Codex32 Strings: The Advantages of 2 Character Quick Checks""","A simpler approach to error correction in Codex32 can be taken with minimal trust by using a mod N = 0 checksum, either by creating the seed such that each share passes, or by storing an additional word/symbol with the seed. This checksum can be computed manually or with a computer and a lookup table, and if all shares have the same checksum, it may be sufficient for everyone to write down the checksums of the other shares, to verify they are correct. Furthermore, generators for degree 2 BCH codes can be divided into quadratic and linear components which allows for ""quickcheck"" verification of strings of any size from 1 character to 13 characters. A 1 character quickchecksum will guarantee detection of any single error, while a 3 character quickchecksum will detect up to two character errors. It is recommended to perform quick checks with a minimum size of 2, as it has a 0.1% failure rate. To increase security, Peter Todd's suggestion of using a lookup table on ""words"" (pairs of Bech32 characters) and adding values together was taken into account, though the addition requires Bech32 rather than calculator addition. Performing 2 character quick checks is an effective way to verify accuracy, as there are 7 different ways of building the table used in this process, and employing each one of them is equivalent to performing a full checksum verification. This has advantages such as catching any new 1 character error introduced since the last visit, and 99.9% chance of catching any other random errors introduced since the last visit."
2023-02-28 18:07:06,[bitcoin-dev] Refreshed BIP324,2,"['Dhruv M', 'Erik Aronesty']","['https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021508.html', 'https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-February/021509.html']","['Anthony Towns proposed changes to the Bitcoin Improvement Proposal (BIP) repository in a pull request on 2/21/23. The proposed changes related to the introduction of short 1-byte message type IDs. By using this new method, messages sent over the Bitcoin network could be identified and routed more efficiently, as they would require only one byte instead of several bytes. This could also improve scalability and reduce latency.', 'When designing a protocol, it is possible to use a byte of data for identification. However, it is recommended to reserve the top bit for use when more space is needed. This technique can be seen in Protocol Buffers (protobuf) where integers are stored. The top bit is set to signal that a two-byte identification is being used instead of the one-byte version. This allows the protocol to expand as needed while still providing efficient storage.']",Exploring Efficient Identification of Bitcoin Network Messages with 1-Byte Message Type IDs,"On 2/21/23, Anthony Towns proposed changes to the Bitcoin Improvement Proposal (BIP) repository in a pull request, introducing short 1-byte message type IDs. This would allow messages sent over the Bitcoin network to be identified and routed more efficiently, as they would only require one byte instead of several bytes, thus improving scalability and reducing latency. When designing a protocol, it is recommended to reserve the top bit for use when more space is needed. This technique, seen in Protocol Buffers (protobuf), stores integers with the top bit set to signal that a two-byte identification is being used instead of the one-byte version, allowing the protocol to expand as needed while still providing efficient storage."
