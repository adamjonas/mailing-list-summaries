<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Sample Newsletter</title>
<link rel="stylesheet" href="style.css">
</head>
<body>
<h1 style="text-align:center; font-family:verdana" >Hello World!</h1>
<br>
<hr style='border-top: dotted 1px; '><h2 style='text-align:center; font-family:verdana;'>[bitcoin-dev] BIP proposal: Fee-redistribution contracts</h2><b>Date: </b><i>2023-02-27 13:32:01</i><p>Number of replies: 3</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>A New Way of Collecting Transaction Fees: Introducing an Improved Mining Environment</h3><b>Author: </b><i>Rastislav Budinsky</i><p>The author is currently working on their Bachelor's thesis which proposes a new way of collecting transaction fees. The proposed solution suggests that instead of the miner taking all of the transaction fees, they take only a fraction (M) and the remaining fraction (C) is sent to one or more contracts. These contracts collect the fees from the miner and then redistribute them back to the miner. This ensures that no new Bitcoins are introduced, but the fees collected are averaged and rewarded back to the miner in a more efficient manner. The paper the author refers to discusses the benefits of this proposal, mainly that it will make mining more secure and predictable against drastic fluctuations in fees. The author believes miners should not oppose this solution as it could ultimately create a better mining environment similar to what mining pools bring. They also discuss if this can be done as a soft-fork since scripts in Bitcoin are stateless, and suggest that a generally spendable script by anyone holding the funds is created with the correct logic of following the contracts embedded into consensus nodes themselves, which may be less disruptive than a hard-fork. The author would like to know the opinions of others about this proposal.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Exploring Mining Incentives in Brno: To Intervene or Not to Intervene</h3><b>Author: </b><i>HcaFc_jbe</i><p>Brno is a beautiful city and the question of long-term miner incentives remains open. Paul proposed an interesting scheme of fee-redistribution to intervene or not intervene with the potential problem. This scheme however has some flaws such as miners being able to exclude high-fee transactions without losing fees, the difficulty in constructing a smart contract for the scheme, consensus on implementing the scheme, and how it affects mining centralization. It is still too early to say whether this problem will even arise and what solution should be applied. A small nit-pick was also addressed that the distribution in block creation is not exponential, but poisson.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Exploring the Possibility of Future Saving through Bitcoin Transaction Fees</h3><b>Author: </b><i>shymaa arafat</i><p>Shymaa M Arafat proposes the concept of "Future Saving" through transaction fees in the Bitcoin community. She suggests that a fee splitting mechanism should be put into place, where a certain ratio of the total fees are saved, and halved with every Bitcoin reward halving until a threshold is reached. This would help to balance out the block reward problem, which is expected to begin before 2140 when mining costs become comparable to the reward value. A game theoretic model would need to be constructed to determine the exact numbers and incentives associated with this proposition.</p><br><hr style='border-top: dotted 1px; '><h2 style='text-align:center; font-family:verdana;'>[bitcoin-dev] Codex32</h2><b>Date: </b><i>2023-02-22 16:29:03</i><p>Number of replies: 6</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Simple Mod N Checksum Verification for Share Validation: A Better Solution than Use-Case</h3><b>Author: </b><i>Peter Todd</i><p>The use-case of Codex32 is not a good selling point since it uses a much more complex approach to verify a share than necessary. A simpler approach would be to use a mod N = 0 checksum either by creating a seed such that each share passes, or by simply storing an additional word/symbol with the seed in order for the sum(words) mod N = 0 to pass. This can be done by hand with a word/symbol->number lookup table, pen and paper, or a calculator. Furthermore, if all shares have mod N checksums, it may be sufficient to make sure that every share holder write down the checksums of the other shares, in order to verify substitution hasn't occurred. It is also possible to generate Shamir's secret sharing shards such that every shard can share the same checksum. In this case, the verification procedure would be to ask every share holder to manually verify the checksum using the mod N procedure, and then verify that each share holder has the same checksum. Small checksums are not foolproof, however using a relatively easy procedure with a 1-in-1000 chance of an error going undetected is more effective than a complex procedure that people don't actually do at all.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Securing Master Secrets with Codex32: An Overview of Prevention Strategies</h3><b>Author: </b><i>Russell O'Connor</i><p>Error correction by hand is far more difficult than the error detection process. A computer can aid in the process, but very little trust is needed as it relies on a checksum. If the final "residue" is different from the value given in the codex32 spec, then there is an error in the share data. The computer can produce an error correction string that can be added to the share to correct it. However, all types of character errors are not equally likely and therefore the computer can learn a bit about the share data. Codex32 does not provide support for nested SSSS and there was a design for a second level share scheme floating around somewhere. It is suggested that wide backups of the derivation path / descriptor data should be made. Hardware wallets provide great protection, however if the secrets are loaded onto a hardware wallet, the isolation must be broken for the wallet to function. There are three main vectors a hardware wallet can communicate: compromising seed/master secret during generation time, lying about public keys at public key generation time and exfiltrating data though signature data or otherwise during signature generation time. Mitigating these threats include anti-exfil signing, air gapping the hardware wallet and using multiple wallets from different vendors. Generating master seeds with digital hardware is unreliable so Codex32 takes this out of the hardware wallet. Generating addresses on diverse hardware and/or using public derivations is recommended to address issue 2. Other attack vectors such as blinking lights or radio broadcasts may require physical support.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Evaluating the Smoothness of Character Generator for Regular Sized Shares</h3><b>Author: </b><i>Russell O'Connor</i><p>This context discusses the possibility of a checksum worksheet for a 13 character generator that is reasonably "smooth" with roots at T{11}, S{16}, and C{24}. It suggests that a 5 bit checksum should be used, however it can be increased to a 10 bit checksum by modulo (x - T)*(x - S). Additionally, a 15 bit checksum is also an option. The smoothness of the long generator for seeds greater than 400 bits has not been looked into yet and if smoother options are available then it should be changed.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>QuickCheck Verification of BCH Codes: Achieving Smooth Generation with Bech32 Addition</h3><b>Author: </b><i>Russell O'Connor</i><p>After consulting with experts, it has been determined that generators for all degree 2 BCH codes can be broken into quadratic and linear components. This means that "quickcheck" verification of codex32 strings can be performed in varying lengths, from 1 character to 13 characters. The shorter the verification, the higher chance of failing to catch errors. For example, a quickcheck of size 2 will guarantee to detect any 1 character error, but only has a 1/1024 chance of failing to detect other random errors. To illustrate this process, let's take the second test vector as an example: "MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM". Starting with the pair of Bech32 characters 'AS', each successive character is then added to the state using a volvelle or lookup table. Following this procedure through to the end of the string gives a final state of 'H9'. By doing this partial verification by hand, it is possible to check strings (up to 400 bit master seeds) quickly, although there is a risk of failing to catch random errors.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>The Compromise of Ease vs Quality: An Analysis of 1 Character Quick Checks</h3><b>Author: </b><i>Russell O'Connor</i><p>In the context of 1 character quick check in Bech32, a procedure has been simplified to use a single table. The specified initial state is the bech32 character '9'. A lookup mapping can be used where (<current state>, <next input character>) -> <next state> is used to go through the table for each character after the prefix, updating the state as you go along until the final state which should be '5' is reached. It is possible to adjust the codex32 generator so that the 1 character quick check table would become identical to the Bech32 addition table but it will come at a cost. It will lose the current property of having three identical coefficients in a row which slightly eases the computation needed when creating checksums by hand (no compromise to the quality of the checksum itself). This adjustment is not recommended as the 1 character quick check is too small to be safely used and it has a 1 in 32 chance of failing to detect more errors. It is recommended to use a minimum size of 2 for quick checks which has a 0.1% failure rate. The difference between using the addition table/volvelle versus a specific table/volvelle for the purpose of performing 1 character quick checks is minimal and therefore the adjustment is not worth compromising the ease of hand computation.</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Maximizing Data Integrity with 2 Character Quick Checks: A Strategy for Accumulating BCH Guarantees</h3><b>Author: </b><i>Russell O'Connor</i><p>This strategy of performing 2 character quick checks suggests that one can regularly visit their shares and perform the different 2 character quick checks in a prescribed order. This will accumulate BCH guarantees as it goes along and is equivalent to doing a full checksum verification. After each table, one is guaranteed to detect specific errors. After the first table, any 1 character error will be detected, followed by any 2 character errors after the second table and so on until any 8 character error after the 7th table. Doing this ensures that the full 13 character checksum is correct. Although more work than doing the full checksum validation, this strategy allows one to spread out the work and still have the guarantee of catching any new errors.</p><br><hr style='border-top: dotted 1px; '><h2 style='text-align:center; font-family:verdana;'>[bitcoin-dev] Refreshed BIP324</h2><b>Date: </b><i>2023-02-28 18:07:06</i><p>Number of replies: 1</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>Addressing Short Message Type IDs in the Bitcoin Protocol</h3><b>Author: </b><i>Dhruv M</i><p>Summary: A Pull Request (PR) has been made to the Bitcoin Improvement Proposals (BIP) repository to make changes to the 1-byte message type IDs. This was proposed by Anthony Towns via Bitcoin Dev on February 21, 23 08:03. The PR can be found at https://github.com/bitcoin/bips/pull/1428. The changes are intended to improve efficiency and clarity with regards to short 1-byte message type IDs.</p><br><hr style='border-top: dotted 1px; '><h2 style='text-align:center; font-family:verdana;'>[bitcoin-dev] Testing censorship resistance of bitcoin p2p network</h2><b>Date: </b><i>2023-02-22 16:39:04</i><p>Number of replies: 1</p><h3 style='text-align:center; font-family:verdana; color:#282828;'>The Power of Flexible Encoding Rules: Achieving Mutually Assured Destruction with OpenTimestamps</h3><b>Author: </b><i>Peter Todd</i><p>Peter suggests that protocols relying on data embedded in Bitcoin transactions should have flexible encoding rules, so that encoders can be adapted quickly if there are any censorship issues. He mentions OpenTimestamps as an example of a protocol that is designed to have this property. This could be compared to Mutually Assured Destruction - if the rules allow data to be encoded in UTXO outputs, then censorship of witness data would risk people switching to filling up the UTXO set. Fees for these protocols vary from 1%, and Peter encourages people not to mess with it.</p><br></body></html>