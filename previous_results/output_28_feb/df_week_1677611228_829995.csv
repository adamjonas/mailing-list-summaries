timestamp,author,subject,email,tokens
2023-02-22 16:29:03+00:00,Peter Todd,[bitcoin-dev] Codex32,"I don't think that use-case is a good selling point. The checksum that Codex32 uses is much more complex than necessary if you are simply verifying a share by itself. A *much* simpler approach would be to use a simple mod N = 0 checksum, either by creating the seed such that each share passes, or by just storing an additional word/symbol with the seed in such a way that sum(words) mod N = 0 passes. This approach is not only possible to compute by hand with a word/symbol->number lookup table, and pen and paper or a calculator. It's so simple they could probably *remember* how to do it themselves. Secondly, if all shares have mod N checksums, it may be sufficient for everyone to write down the checksums of the *other* shares, to verify they are the correct ones and a different (otherwise correct) share hasn't accidentally been substituted. Indeed, with some brute forcing and small checksums, I'd expect it to be mathematically possible to generate Shamir's secret sharing shards such that every shard can share the *same* checksum. In which case the share verification procedure would be to simply ask every share holder to verify the checksum manually using the mod N procedure, and then verify that each share holder has the same checksum. This would be less error prone in terms of leaking information accidentally if the checksum was obviously *not* part of the share: eg by encoding the share with words, and the checksum with a number. Obviously, small checksums aren't fool proof. But we're probably better off creating a relatively easy procedure with a 1-in-1000 chance of an error going undetected than a complex procedure that people don't actually do at all. https://petertodd.org 'peter'[:-1]@petertodd.org",375
2023-02-22 16:39:04+00:00,Peter Todd,[bitcoin-dev] Testing censorship resistance of bitcoin p2p network,"I would definitely call ~1% trivial. Fees vary more by that on an hour to hour basis. Anyway, it goes to show that protocols relying on data embedded in Bitcoin transactions would do well to have flexible encoding rules, eg by considering all PUSHDATA's with certain characteristics to be data, so that encoders can be adapted on the fly if there are any censorship issues. It's also useful if the rules allow data to be encoded in UTXO outputs, so that censorship of witness data always risks people switching to filling up the UTXO set. A kind of Mutually Assured Destruction threat in a way. FWIW, OpenTimestamps was deliberately designed to have this property. So don't mess with it. :D https://petertodd.org 'peter'[:-1]@petertodd.org",167
2023-02-22 17:24:19+00:00,Russell O'Connor,[bitcoin-dev] Codex32,"While perhaps not entirely impossible, doing error correction by hand is far more difficult than just the error detection process. Fortunately, error correction can be aided by a computer needing very little trust. When doing hand computation of the checksum, there is an error if the final ""residue"" is different from the value given in the codex32 spec. After double checking your hand computation by redoing it, if you still get the same incorrect residue, there is an error in your share data somewhere. What you can do is plug in the residue that you did compute into a computer, and have it produce an error correction string. You can then, by hand, add this error correction string to your share to get a corrected share. If it were the case that all types of character errors were equally likely (as in during an error any character is equally likely to be transformed into any other character), then the computer would gain zero information about your actual share data. Of course, it is not in fact the case that all transcription errors are equally likely, and so the computer can learn a little bit about your share. The fewer errors that are made, the less data it can recover. If you only have one character in error, then 5 bits is the most data it can recover, and that is assuming that it can somehow infer your error perfectly from the delta of the error correction, which isn't actually going to be the case. Of course, a single share from a split secret has no information about your master seed (the master seed is hidden in the correlation between different shares). So learning partial information about one share isn't going to be enough by itself to even begin compromising your master key. This all still needs to be written up in more detail, but I figured I would give a preview here. - Hierarchy: Codex32 does not natively provide support for nested SSSS There was a design for a second level share scheme floating around somewhere. I'll have to dig it up. As I recall this is made slightly more complicated by needing to incorporate share metadata (i.e. the share index) when doing a second split, but it seemed doable at the time. Personally, I don't consider the derivation path / descriptor data as that sensitive, and I would recommend making wide backups of that data. It certainly would make sense to store descriptor data alongside wherever you keep your shares, and more places beyond that. On the other hand, if you are trying to keep your shares innocuous somehow, perhaps you won't be able to keep the descriptor data alongside your shares. When I first saw the post about this, it was unclear to me that it was a I do think hardware wallets are great, and overall provide a lot of practical protection. What is notable is that once the secrets are loaded onto a hardware wallet, as long as that wallet remains isolated, it cannot leak any secrets. Of course, a wallet needs to interact with the Bitcoin protocol and P2P network, at least indirectly, in order to function, so we must break that isolation. However, if we can limit the communication capabilities of a hardware wallet, even a malicious wallet shouldn't be able to leak the secret data. There are three main vectors a hardware wallet can try to communicate that I am aware of: 1. Compromise at seed/master secret (or in this case shares of the master secret) during generation time. 2. Lie about public keys at public key generation time. 3. Exfiltrate data though signature data or otherwise during signature generation time. 3 is largely mitigated through using anti-exfil signing and air gapping the hardware wallet (e.g. using QR codes, or using RS-232 <https://en.wikipedia.org/wiki/RS-232> if you consider that air gaping). Using multiple wallets from different vendors doing deterministic signing is another possibility, but I consider the method deprecated in favour of anti-exfil. Addressing 1 is where codex32 lies, by taking master secret handling functions out of the hardware wallet. My understanding is that it is difficult for digital hardware, which tries very hard to be deterministic, to generate randomness, especially for isolated hardware devices like hardware wallets. Also it is hard for hardware to tell if their hardware random number generator is broken. Generally I don't trust small pieces of isolated digital hardware to generate master seeds, even when they are not malicious. This may just be due to my ignorance of how they operate. 2 seems to be the hardest issue to address. My current thinking is to generate addresses on a diverse set of hardware and/or using public derivations. Perhaps an alternative to BIP-32 could be designed to make it easy to generate zero-knowledge proofs of pubkey derivations. Of course there are other ways for a hardware wallets to exfiltrate data: The wallet can blink lights, make noise, or it can try to use radio broadcasts, etc. These other attack vectors seem to require physically local support, which is a fairly big hurdle to overcome. I suppose even these vectors could be mitigated through various levels of tinfoil.",1035
2023-02-22 19:01:10+00:00,Russell O'Connor,[bitcoin-dev] Codex32,"After some poking around at the math, I do see that the 13 character generator (for regular sized shares) is reasonably ""smooth"", having roots at T{11}, S{16}, and C{24}. This means we could build a ""quick check"" worksheet to evaluate the string modulo (x - T) to verify a 5 bit checksum, whose operation would be similar to the existing checksum worksheet in structure but significantly less work. Perhaps 5 bits is too short, and it is more reasonable working modulo (x - T)*(x - S) to get a 10 bit checksum. A worksheet for a 15 bit checksum is also an option, and possibly others well depending on the size of the other factors. I think this process is would be about as simple as any other comparable hand operated checksum over the bech32 alphabet would be. I haven't looked into the smoothness of the long generator for seeds that are greater than 400 bits. If it isn't smooth and smoother options are available, perhaps it should be changed.",213
2023-02-23 03:30:10+00:00,Russell O'Connor,[bitcoin-dev] Codex32,"After some consultation, I now see that generators for all degree 2 BCH codes, such as ours, are smooth and factor into quadratic and linear components. Anyhow the upshot of all this is that you can perform a ""quickcheck"" verification of the codex32 strings for whatever size of verification you want to do, 1 character, 2 characters, 3 characters, upto the full 13 characters. Each of these partial verifications will have BCH properties. A 1 character quickchecksum will guarantee to detect any 1 character error. A 3 character quickchecksum will guarantee to detect any 2 character error, etc. There remains a 1 in 32^n chance of failing to detect larger numbers of errors where n is the size of your quickcheck. To illustrate, let's consider a quickcheck of size 2. This can detect any 1 character error and will only have a 1/1024 chance of failing to detect other random errors. Let's take the second test vector as our example: "" MS12NAMEA320ZYXWVUTSRQPNMLKJHGFEDCAXRPP870HKKQRM"" You start in a specified initial state with a pair of bech32 characters. For MS1 strings and a size 2 quickcheck it would be the pair of Bech32 characters 'AS'. Next we ""add"" the first character after the prefix, which is '2' by using the addition volvelle or lookup table. ""Adding"" '2' to 'S' yields '6' and our state becomes 'A6'. Next we have to look up 'A6' in a lookup table. This table is too big to fit in the margin of this email, so I will have to omit it. But it would have an entry mapping 'A6' -> 'QM'. Our state becomes 'QM' string and we can work 2 characters at a time. We ""add"" the next two data characters from our string, which are 'NA'. Again, using the volvelle or lookup table we get that adding 'N' to 'Q' yields 'N', and adding 'A' to 'M' yields 'X'. So our state is now 'NX' Next we look up 'NX' in this table I haven't given you and we will find an entry mapping 'NX' -> 'DX', making 'DX' our new state. We keep repeating this process alternating between adding pairs of characters and using this unstated lookup table all the way until the end where we will reach a final state which will be 'H9'. If you follow this procedure with any string (upto 400 bit master seeds) you will always end up in the state 'H9'. A specialized worksheet would help guide the process making the process easier to follow. This process is somewhat close to Peter Todd's suggestion of using a lookup table on ""words"", which in this case would be pairs of bech32 characters, and adding values together. The catch is that the addition is done with Bech32 addition rather than calculator addition, which I accept is a moderately large catch. Anyhow, the point is that you can do this sort of partial verification by hand to whatever degree you like, if you are in a rush and are willing to accept larger chances of failing to catch random errors. wrote:",690
2023-02-23 16:36:59+00:00,Russell O'Connor,[bitcoin-dev] Codex32,"Sorry for the repeated replies, but I would like to make one more remark regarding the 1 character ""quick check"". Because the 1 character ""quick check"" state is so small, the procedure becomes simplified to just using a single table. You start with the specified initial state, which would be the bech32 character '9', and then you have a lookup mapping (<current state>, <next input character>) -> <next state>. You go through the table for each character after the prefix, updating the state as you go along. ('9','2') -> '0', then ('0','N') -> '4', and so on until you reach the final state which should be '5'. If you like volvelles, one could be designed to implement this lookup table. However, I do want to note that an adjustment could be made to the codex32 generator so that this 1 character ""quick check"" table would become identical to the Bech32 addition table. In other words the 1 character quick check would become the same as adding up all the characters and checking that you get the required final constant. If this change were free to make, I would probably make it. However such an adjustment would come at a cost. The current generator was chosen to have three identical coefficients in a row (you can find the generator in the appendix of the draft BIP). This special property slightly eases the computation needed when creating checksums by hand (no compromise to the quality of the checksum itself). If we made the above adjustment to the codex32 generator, we would lose this property of having three identical coefficients in a row. Therefore, I am pretty hesitant to make this adjustment. Firstly the 1 character quick check is simply too small to be safely used. While it does guarantee to detect single character errors, it has a 1 in 32 chance of failing to detect more errors. I think a 3% failure rate is pretty bad, and would definitely recommend people performing quick checks use a minimum size of 2 (which has a 0.1% failure rate). Secondly the difference between using the addition table/volvelle versus a specific table/volvelle for the purpose of performing 1 character quick checks (which you ought not to be doing anyways) is pretty minimal. The addition table is possibly slightly less error prone to use because it is symmetric, but other than that the amount of work to do is pretty much the same either way. My conclusion is that it isn't worth compromising the ease of hand computation for the sake of possibly making a too-low-quality-checksum-that-no-one-should-be-using slightly more convenient, but I thought I should mention it at least. wrote:",552
2023-02-23 18:26:17+00:00,Russell O'Connor,[bitcoin-dev] Codex32,"One more thing (Again apologies. This idea of doing partial verification is novel to me, and I see now that I should have just waited to give a consolidated reply). Focusing in on the example of performing 2 character quick checks. There are 7 different ways of building the table used in this quick check verification process (actually there are 8, but we only need 7 of them for our purposes here). Fun fact: If you perform the 2 character quick check in all 7 different ways, this is equivalent to doing a full checksum verification. This suggests a strategy of visiting your shares on a regular basis and performing a different 2 character quick check each time, rotating through the 7 different ways of performing it. Moreover, these 7 different 2 character quick checks come with a prescribed order that will accumulate BCH guarantees as you go along. Assuming the string isn't changing between visits then * After the 1st table you are guaranteed to detect any 1 character error. * After the 2nd table you are guaranteed to detect any 2 character error. * After the 3rd table you are guaranteed to detect any 4 character error. * After the 4th table you are guaranteed to detect any 5 character error. * After the 5th table you are guaranteed to detect any 6 character error. * After the 6th table you are guaranteed to detect any 7 character error. * After the 7th table you are guaranteed to detect any 8 character error, which is the guarantee of the full 13 character checksum. You are also guaranteed that the full 13 character checksum is now correct. You could perform the checks out of order, and that is okay. You will eventually reach these BCH levels of guarantees, just not as quickly as if you follow the prescribed order. Of course, doing a series of 7 different 2 character quick checks is overall more work than doing the full 13 character checksum validation. But there is certainly an advantage in spreading the work out over time. Each time you visit you still have the guarantee of catching any new 1 character error introduced since the last time you visited and a 99.9% chance of catching any other random errors introduced since your last visit. Personally I am likely to follow such a validation strategy myself, now that I am aware of it. wrote:",482
2023-02-27 13:32:01+00:00,Rastislav Budinsky,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"Hello, I am working on my Bachelor's thesis, in which a new way of collecting transaction fees is introduced or rather how they are distributed. When a miner mines a block he takes all the fees currently. However with the proposed solution he takes only fraction M and remaining fraction C is sent to one of more contracts. One contract at its simplest collects fees from the miner and at the same time redistributes it back to the miner. This means no new Bitcoins are introduced, only the one collected from fees are collected, averaged and rewarded back to the miner in a ""smarter"" way. We can have multiple such contracts, where each averages the collected fees over different time frames. I would like to refer you to our paper for more details [1], which is not yet in the final form. Benefits are discussed in the paper [1] as well, mainly it should make mining more secure and predictable against drastic fluctuations in fees. I personally do not think miners should oppose this solution as for most miners it should make a better mining environment. Similarly in a sense to what mining pools bring. I would like to know your opinions about this proposal and we can also discuss the needed parameters introduced with such a solution if you are in favor of it or think it might be interesting. Introducing this solution soon enough will not make a great difference to miners with current block rewards and at the same time the contracts will be adapted before transaction fees become the main source of income for miners. As I have very little to none developer experience from blockchain's point (especially on Bitcoin), I am not sure if this would be possible as soft-fork as scripts in Bitcoin are stateless I suppose. However maybe a generally spendable script by anyone holding the funds is created, which a miner of the block would be the one spending it, and the correct logic of following the contracts is embedded into consensus nodes themselves. Thus perhaps a less disruptive solution to hard-fork. Once again, I would love to know your opinions about this & I apologize for making this a bit less conventional BIP proposal. Best regards.",421
2023-02-27 21:41:35+00:00,HcaFc_jbe,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"Greetings, Brno is a beautiful city. Long term miner incentives remain an open question, and this is an interesting proposal, but it has flaws. -----To intervene or not intervene --No intervention: When block subsidies do run out, years from now, it's possible that we live in a world where ordinals, LN-settlements, and on-chain transactions will be filling block space to the extent that miners are incentivized to continue mining. --Intervention: Tail-emissions? Demurrage? Fee-redistribution schemes like this one? Really, it is too early to say whether mining incentives _will even_ be a problem, let alone _what_ the solution(s) should be. This fee-redistribution scheme aims to solve 1. Undercutting attacks [which have been precluded AFAIK with anti fee-sniping nLocktime since Core 0.11] 2. Fee-variance between blocks, whether due to the mining gap or variance in block demand. --Flaws 0. A miner in this world could be more aggressive in excluding certain blocks to the detriment of their counter parties. I.e. If a miner can ignore high-fee transactions, knowing they won't receive the _benefits_ of mining them [or less benefit], they can exclude these transactions without losing fees. E.g. if a miner is or represents a counterparty in a LN commitment transaction, and this counter party prefers that a time threshold is reached [so that they can mine a different version of the commitment transaction] then under this scheme they can avoid mining the first commitment transaction without really losing its fee, since it's fee is socialized anyway. This attack then becomes free or very cheap. 1. How would this smart-contract actually be constructed? The paper contains no references to op_codes or implementations. You do mention that you are not a bitcoin dev, so that's fair. AFAIK this isn't even _possible_ with the current Script, and could remain impossible. Maybe DLCs could be applied somehow. IDK. 2.0. I think it will be difficult to convince the ecosystem that the mining incentive structure should be changed from competitive to cooperative. This effectively changes the mining ecosystem into one giant mining pool. How would this affect mining centralization? 2.1. How do we achieve miner consensus in implementing the fee-redistribution scheme? And what is the consensus for updating? ---Paper-nits: I believe the distribution in block creation is not exponential, but poisson -> on page two it's described as exponential. Cheers, -Paul ------- Original Message -------",530
2023-02-28 10:02:47+00:00,shymaa arafat,[bitcoin-dev] BIP proposal: Fee-redistribution contracts,"If you allow me to comment (just with a bird eye, have not read the paper only the abstract) I think the Bitcoin community may consider the intuition of somewhat ""Future Saving"" through TX fees: ie, the idea of saving a ratio of the fees (say half to be decreased to half with each reward halving)is worth thinking of: Keep in mind that the block reward problem will not start only in 2140, but when the mining cost becomes comparable to the reward value (could this be as near as 2040?I don't know, you know the answer better than me) . -So, why not start a fee splitting mechanism in analogy to reward splitting mechanism *(the saved ratio is half the total now, and to be halved with every Bitcoin reward halving until a threshold is reached where the saved amounts gets added to the low block reward)* Ofcourse this is very rough, a game theoritic model has to be built with the appropriate incentives and costs to get the exact numbers . Thank you for letting me comment in your list . Regards . Shymaa M Arafat",225
2023-02-28 18:07:06+00:00,Dhruv M,[bitcoin-dev] Refreshed BIP324,"The relevant changes from this discussion about short 1-byte message type IDs are now in a PR for the bips repo: https://github.com/bitcoin/bips/pull/1428 On 2/21/23 08:03, Anthony Towns via bitcoin dev wrote:",58
